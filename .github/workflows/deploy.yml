# GitHub Actions workflow for deploying a Laravel project to Hostinger
# This workflow handles a split directory structure where the main application
# and the public assets are in separate locations on the server.

name: Deploy via SSH (Hostinger split app/public)

# Triggers the workflow on push events to the main branch
# and also allows manual triggering from the Actions tab (workflow_dispatch).
on:
  push:
    branches: [ main ]
  workflow_dispatch:

env:
  # Define the directory of your Laravel project within the repository.
  # This is used to set the working directory for most steps.
  PROJECT_DIR: vibe-playlistsw

jobs:
  deploy:
    runs-on: ubuntu-latest

    defaults:
      run:
        shell: bash
        # All 'run' steps will execute inside this directory.
        working-directory: ${{ env.PROJECT_DIR }}

    steps:
      # Step 1: Check out the repository code
      - name: Checkout
        uses: actions/checkout@v4

      # Step 2: Set up Node.js environment for building frontend assets.
      # This block is conditional and only runs if a package.json file exists.
      - name: Setup Node
        if: hashFiles('vibe-playlistsw/package.json') != ''
        uses: actions/setup-node@v4
        with:
          node-version: 20

      # Step 3: Install Node.js dependencies using a lockfile for consistency.
      - name: Install Node deps (lockfile)
        if: ${{ hashFiles('vibe-playlistsw/package-lock.json', 'vibe-playlistsw/npm-shrinkwrap.json') != '' }}
        run: npm ci

      # Step 4: Install Node.js dependencies if no lockfile is present.
      - name: Install Node deps (no lockfile)
        if: ${{ hashFiles('vibe-playlistsw/package-lock.json', 'vibe-playlistsw/npm-shrinkwrap.json') == '' && hashFiles('vibe-playlistsw/package.json') != '' }}
        run: npm install --no-audit --no-fund --legacy-peer-deps

      # Step 5: Build frontend assets using Vite.
      - name: Build assets (Vite)
        if: ${{ hashFiles('vibe-playlistsw/package.json') != '' }}
        run: npm run build

      # Step 6: Prepare SSH connection by setting up the private key and known_hosts.
      - name: Prepare SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_KEY_B64 }}" | base64 -d > ~/.ssh/id_ed25519
          chmod 600 ~/.ssh/id_ed25519
          ssh-keyscan -p "${{ secrets.SSH_PORT }}" -t ed25519 "${{ secrets.SSH_HOST }}" >> ~/.ssh/known_hosts
        # The working-directory default is overridden here to run in the root.
        working-directory: .

      # Step 7: Stage application and public files.
      - name: Stage app files
        run: |
          rm -rf _stage_app _stage_pub _app _pub
          mkdir -p _stage_app _stage_pub

          # Stage the whole app but skip heavy/ephemeral stuff
          rsync -a \
            --exclude='.git' \
            --exclude='node_modules' \
            --exclude='vendor' \
            --exclude='storage/framework/cache/*' \
            --exclude='storage/logs/*' \
            ./ _stage_app/

          # Stage public files from the already staged app directory
          rsync -a _stage_app/public/ _stage_pub/

      # Step 8: Create a compressed tarball of the application files.
      - name: Create app bundle
        run: |
          rm -rf _app && mkdir -p _app
          tar --warning=no-file-changed -C _stage_app -czf _app/app.tar.gz . || true

      # Step 9: Create a compressed tarball of the public files.
      - name: Create public bundle
        run: |
          rm -rf _pub && mkdir -p _pub
          tar --warning=no-file-changed -C _stage_pub -czf _pub/public.tar.gz . || true

      # Step 10: Upload the application and public bundles to the server.
      - name: Upload bundles to server
        run: |
          scp -P "${{ secrets.SSH_PORT }}" _app/app.tar.gz _pub/public.tar.gz \
            "${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }}:~/"
          # Optionally upload a custom index file for Hostinger.
          if [ -f index.hostinger.php ]; then
            scp -P "${{ secrets.SSH_PORT }}" index.hostinger.php \
              "${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }}:~/index.hostinger.php"
          fi

      # Step 11: Execute the deployment script on the remote server.
      # This script unpacks bundles, sets up dirs, installs deps, and runs Artisan commands.
      - name: Deploy on server (composer + artisan + publish public)
        run: |
          ssh -p "${{ secrets.SSH_PORT }}" "${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }}" \
            "APP_PATH='${{ secrets.APP_PATH }}' PUBLIC_PATH='${{ secrets.PUBLIC_PATH }}' bash -s" <<'EOSSH'
          set -e
          : "${APP_PATH:?APP_PATH not set}"
          : "${PUBLIC_PATH:?PUBLIC_PATH not set}"

          # --- pick PHP 8.3 for CLI ---
          if [ -x /opt/alt/php83/usr/bin/php ]; then
            PHP_BIN=/opt/alt/php83/usr/bin/php
          elif command -v php83 >/dev/null 2>&1; then
            PHP_BIN="$(command -v php83)"
          else
            PHP_BIN="$(command -v php)"
          fi
          echo "Using PHP: $PHP_BIN"
          "$PHP_BIN" -v

          mkdir -p "$APP_PATH" "$PUBLIC_PATH"

          # Unpack bundles uploaded by the workflow, clearing old files first
          if [ -f "$HOME/public.tar.gz" ]; then
            rm -rf "$PUBLIC_PATH"/*
            tar -xzf "$HOME/public.tar.gz" -C "$PUBLIC_PATH" && rm -f "$HOME/public.tar.gz"
          fi
          [ -f "$HOME/app.tar.gz" ] && tar -xzf "$HOME/app.tar.gz" -C "$APP_PATH" && rm -f "$HOME/app.tar.gz"

          # Optional Hostinger index shim into public/
          if [ -f "$HOME/index.hostinger.php" ]; then
            mv -f "$HOME/index.hostinger.php" "$PUBLIC_PATH/index.php"
          fi

          cd "$APP_PATH"

          # --- Ensure cache/storage dirs exist BEFORE composer scripts run ---
          mkdir -p storage/framework/cache/data \
                   storage/framework/sessions \
                   storage/framework/views \
                   bootstrap/cache

          # Reasonable perms for shared hosting (adjust if needed)
          chmod -R 775 storage bootstrap/cache || true

          # --- Prepare .env if missing (keeps post-scripts happy) ---
          [ -f .env ] || cp -f .env.example .env || true
          # If APP_KEY empty, generate one
          if ! grep -q "^APP_KEY=" .env || [ -z "$(grep '^APP_KEY=' .env | cut -d= -f2)" ]; then
            "$PHP_BIN" artisan key:generate --force || true
          fi

          # --- Composer 2 (local phar so we control the version) ---
          "$PHP_BIN" -r "copy('https://getcomposer.org/installer','composer-setup.php');"
          "$PHP_BIN" composer-setup.php --2 --filename=composer.phar
          "$PHP_BIN" composer.phar --version

          # Install deps; now post-autoload-dump (artisan config:clear) will succeed
          "$PHP_BIN" composer.phar install --no-dev --prefer-dist --optimize-autoloader --no-interaction

          # --- App bootstrap / optimize ---
          "$PHP_BIN" artisan storage:link    || true
          "$PHP_BIN" artisan migrate --force || true
          "$PHP_BIN" artisan optimize:clear  || true
          "$PHP_BIN" artisan optimize        || true
          EOSSH
